{"version":3,"file":"prepareTokenParams.js","names":["assertPKCESupport","sdk","features","isPKCESupported","errorMessage","isHTTPS","hasTextEncoder","AuthSdkError","validateCodeChallengeMethod","codeChallengeMethod","options","DEFAULT_CODE_CHALLENGE_METHOD","wellKnownResponse","getWellKnown","methods","indexOf","preparePKCE","tokenParams","codeVerifier","codeChallenge","PKCE","generateVerifier","computeChallenge","responseType","prepareTokenParams","defaults","getDefaultTokenParams","pkce"],"sources":["../../../../lib/oidc/util/prepareTokenParams.ts"],"sourcesContent":["/* eslint-disable complexity */\n/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and limitations under the License.\n *\n */\nimport { getWellKnown } from '../endpoints/well-known';\nimport { AuthSdkError } from '../../errors';\nimport { OktaAuthOAuthInterface, TokenParams } from '../types';\nimport { getDefaultTokenParams } from './defaultTokenParams';\nimport { DEFAULT_CODE_CHALLENGE_METHOD } from '../../constants';\nimport PKCE from './pkce';\nimport { OktaAuthBaseInterface } from '../../base/types';\n\nexport function assertPKCESupport(sdk: OktaAuthBaseInterface) {\n  if (!sdk.features.isPKCESupported()) {\n    var errorMessage = 'PKCE requires a modern browser with encryption support running in a secure context.';\n    if (!sdk.features.isHTTPS()) {\n      // eslint-disable-next-line max-len\n      errorMessage += '\\nThe current page is not being served with HTTPS protocol. PKCE requires secure HTTPS protocol.';\n    }\n    if (!sdk.features.hasTextEncoder()) {\n      // eslint-disable-next-line max-len\n      errorMessage += '\\n\"TextEncoder\" is not defined. To use PKCE, you may need to include a polyfill/shim for this browser.';\n    }\n    throw new AuthSdkError(errorMessage);\n  }\n}\n\nexport async function validateCodeChallengeMethod(sdk: OktaAuthOAuthInterface, codeChallengeMethod?: string) {\n  // set default code challenge method, if none provided\n  codeChallengeMethod = codeChallengeMethod || sdk.options.codeChallengeMethod || DEFAULT_CODE_CHALLENGE_METHOD;\n\n  // validate against .well-known/openid-configuration\n  const wellKnownResponse = await getWellKnown(sdk);\n  var methods = wellKnownResponse['code_challenge_methods_supported'] || [];\n  if (methods.indexOf(codeChallengeMethod) === -1) {\n    throw new AuthSdkError('Invalid code_challenge_method');\n  }\n  return codeChallengeMethod;\n}\n\nexport async function preparePKCE(\n  sdk: OktaAuthOAuthInterface, \n  tokenParams: TokenParams\n): Promise<TokenParams> {\n  let {\n    codeVerifier,\n    codeChallenge,\n    codeChallengeMethod\n  } = tokenParams;\n\n  // PKCE calculations can be avoided by passing a codeChallenge\n  codeChallenge = codeChallenge || sdk.options.codeChallenge;\n  if (!codeChallenge) {\n    assertPKCESupport(sdk);\n    codeVerifier = codeVerifier || PKCE.generateVerifier();\n    codeChallenge = await PKCE.computeChallenge(codeVerifier);\n  }\n  codeChallengeMethod = await validateCodeChallengeMethod(sdk, codeChallengeMethod);\n\n  // Clone/copy the params. Set PKCE values\n  tokenParams = {\n    ...tokenParams,\n    responseType: 'code', // responseType is forced\n    codeVerifier,\n    codeChallenge,\n    codeChallengeMethod\n  };\n\n  return tokenParams;\n}\n\n// Prepares params for a call to /authorize or /token\nexport async function prepareTokenParams(\n  sdk: OktaAuthOAuthInterface,\n  tokenParams: TokenParams = {}\n): Promise<TokenParams> {\n  // build params using defaults + options\n  const defaults = getDefaultTokenParams(sdk);\n  tokenParams = { ...defaults, ...tokenParams };\n\n  if (tokenParams.pkce === false) {\n    // Implicit flow or authorization_code without PKCE\n    return tokenParams;\n  }\n\n  return preparePKCE(sdk, tokenParams);\n}"],"mappings":";;;;;;;AAaA;AACA;AAEA;AACA;AACA;AAlBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AASO,SAASA,iBAAiB,CAACC,GAA0B,EAAE;EAC5D,IAAI,CAACA,GAAG,CAACC,QAAQ,CAACC,eAAe,EAAE,EAAE;IACnC,IAAIC,YAAY,GAAG,qFAAqF;IACxG,IAAI,CAACH,GAAG,CAACC,QAAQ,CAACG,OAAO,EAAE,EAAE;MAC3B;MACAD,YAAY,IAAI,kGAAkG;IACpH;IACA,IAAI,CAACH,GAAG,CAACC,QAAQ,CAACI,cAAc,EAAE,EAAE;MAClC;MACAF,YAAY,IAAI,wGAAwG;IAC1H;IACA,MAAM,IAAIG,oBAAY,CAACH,YAAY,CAAC;EACtC;AACF;AAEO,eAAeI,2BAA2B,CAACP,GAA2B,EAAEQ,mBAA4B,EAAE;EAC3G;EACAA,mBAAmB,GAAGA,mBAAmB,IAAIR,GAAG,CAACS,OAAO,CAACD,mBAAmB,IAAIE,wCAA6B;;EAE7G;EACA,MAAMC,iBAAiB,GAAG,MAAM,IAAAC,uBAAY,EAACZ,GAAG,CAAC;EACjD,IAAIa,OAAO,GAAGF,iBAAiB,CAAC,kCAAkC,CAAC,IAAI,EAAE;EACzE,IAAIE,OAAO,CAACC,OAAO,CAACN,mBAAmB,CAAC,KAAK,CAAC,CAAC,EAAE;IAC/C,MAAM,IAAIF,oBAAY,CAAC,+BAA+B,CAAC;EACzD;EACA,OAAOE,mBAAmB;AAC5B;AAEO,eAAeO,WAAW,CAC/Bf,GAA2B,EAC3BgB,WAAwB,EACF;EACtB,IAAI;IACFC,YAAY;IACZC,aAAa;IACbV;EACF,CAAC,GAAGQ,WAAW;;EAEf;EACAE,aAAa,GAAGA,aAAa,IAAIlB,GAAG,CAACS,OAAO,CAACS,aAAa;EAC1D,IAAI,CAACA,aAAa,EAAE;IAClBnB,iBAAiB,CAACC,GAAG,CAAC;IACtBiB,YAAY,GAAGA,YAAY,IAAIE,aAAI,CAACC,gBAAgB,EAAE;IACtDF,aAAa,GAAG,MAAMC,aAAI,CAACE,gBAAgB,CAACJ,YAAY,CAAC;EAC3D;EACAT,mBAAmB,GAAG,MAAMD,2BAA2B,CAACP,GAAG,EAAEQ,mBAAmB,CAAC;;EAEjF;EACAQ,WAAW,GAAG;IACZ,GAAGA,WAAW;IACdM,YAAY,EAAE,MAAM;IAAE;IACtBL,YAAY;IACZC,aAAa;IACbV;EACF,CAAC;EAED,OAAOQ,WAAW;AACpB;;AAEA;AACO,eAAeO,kBAAkB,CACtCvB,GAA2B,EAC3BgB,WAAwB,GAAG,CAAC,CAAC,EACP;EACtB;EACA,MAAMQ,QAAQ,GAAG,IAAAC,yCAAqB,EAACzB,GAAG,CAAC;EAC3CgB,WAAW,GAAG;IAAE,GAAGQ,QAAQ;IAAE,GAAGR;EAAY,CAAC;EAE7C,IAAIA,WAAW,CAACU,IAAI,KAAK,KAAK,EAAE;IAC9B;IACA,OAAOV,WAAW;EACpB;EAEA,OAAOD,WAAW,CAACf,GAAG,EAAEgB,WAAW,CAAC;AACtC"}